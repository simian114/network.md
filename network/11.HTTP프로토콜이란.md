# HTTP프로토콜이란?



## HTTP 프로토콜

#### 웹을 만드는 기술들

> 웹을 만들기 위해 사용되는 다양한 기술들.

- 필수
  - `HTTP 프로토콜` 
    - HTML과 JS, CSS같은 파일을 웹 서버에게 요청하고 받아오는 프로토콜
  - `HTML,  CSS, Javascript`
    - 프론트엔드 
    - 웹표준코드 - 클라이언트에서 동작함.
    - 클라이언트가 `HTTP프로토콜`로 서버로부터 다운받아 오기 때문에 직접 볼 수 있음
  - `ASP/ASP.NET, JSP, PHP`
    - 백엔드
    - 웹 서버 페이지를 만드는 기술
    - 서버에서 동작하고 그 결과만을 전송하기 때문에 클라이언트가 직접 볼 수 없다.
  - `DB`
- 선택
  - `Python`
  - `Spring`
  - `Jquery`
  - `Ajax`

#### HTTP 프로토콜의 특징

- `HyoerText Transfer Protocol (하이퍼 텍스트 전송 프로토콜)`
  - `www`에서 쓰이는 핵심 프로토콜로 문서의 전송을 위해 쓰이며, 오늘날 거의 모든 웹 어플리케이션에서 사용되고 있다.
    - 음성, 화상 등 여러 종류의 데이터를 MIME로 정의하여 전송이 가능하다.
- HTTP 특징
  - Request / Reponse (요청/응답) 동작에 기반하여 서비스 제공한다.
  - `HTTP 1.0`의 특징
    - "연결 수립, 동작, 연결 해제"의 단순함이 특징 -> 하나의 URL은 하나의 TCP에 연결
    - HTML문서를 전송 받은 뒤 연결을 끊고 다시 연결하여 데이터를 전송한다.
  - `HTTP 1.0`의 문제점
    - 단순 동작 (연결 수립, 동작, 연결 해제)이 반복되어 통신 부하 문제가 발생한다.
  - `HTTP 1.1`의 특징
    - `HTTP 1.0`과 호환  가능
    - `Multiple Request` 처리가 가능하여 클라이언트의 요청이 많을 경우 연속적인 응답 제공이 가능하다 -> Pipeline 방식의 Request / Response 진행
    - `HTTP 1.0`과는 달리 서버가 갖는 하나의 `IP주소`와 다수의 `Web site`연결이 가능하다.
    - 빠른 속도와 `Internet Protocol` 설계에 최적화 될 수 있도록 `Cache` 사용. `Data`를 압축해서 전달이 가능하도록 하여 전달하는 `Data`양이 감소

#### HTTP 프로토콜의 통신 과정

- `TCP`에서 `3WayHandShake` 를 통해 연결을 한다고 했었는데, `HTTP1.0`은 하나 보낼 때 마다 이 과정을 다시 반복한다.
- 따라서 오버헤드가 엄청 걸리게 됨.
- 반대로 `HTTP 1.1`은`3WS`가 처음에 딱 한번 일어나고 끝

## HTTP 요청 프로토콜

#### HTTP 요청 프로토콜의 구조

> 요청하는 방식을 정의 하고 클라이언트의 정보를 담고 있다.

| http 요청 프로토콜 계층구도 |                                           |
| --------------------------- | ----------------------------------------- |
| RequestLine                 | `요청타입 | 공백 | URI | 공백 | HTTP버전` |
| Headers                     | 아래에서 자세히                           |
| 공백                        | 말 그대로 공백. 구분자의 역할을 한다.     |
| BODY                        |                                           |



### Request Line

#### 요청 타입

> 종류가 굉장히 많다. 일단은 GET과 POST가 제일 중요하고 나머지는 보안상의 이유 또는 쓸모 없음으로 인해 거의 사용하지 않는다.

- `GET`: 클라이언트가 서버로부터 문서를 읽어오려할 때 사용한다. 하지만 요청하는 동시에 데이터를 전송할 수 있다.
- `POST`: 클라이언트가 서버로 데이터를 전송할 떄 주로 사용된다. 하지만 데이터를 요청할 때도 사용할 수 있다.
- 즉, POST, GET 모두 데이터를 전송하고 요청할 수 있다. 그렇다면 차이가 무엇이냐?
  - `GET`은 데이터를 전송할 때 ```URI``` 에 붙여서 전송한다! 즉 우리가 전송하는 데이터가 URL에 모두 보인다는 것. 따라서 보안상에  큰 에러가 있다. 만약 우리가 네이버 웹툰을 본다고 생각해보자. 웹툰 목록에 들어가면 요일별로 많은 웹툰이 있는데 여기서 ```목요일``` 버튼을 누르면 우리는 서버에게 목요일 웹툰 페이지를 요청한다. 이 요청을 할 때 요청이라는 데이터를 전송하는데 이게 ```URL```을 베이스로 하게된다. 즉, 우리가 목요일 웹툰을 누르고 주소창을 보면 ``~~~/thu/~~~`` 라는 문구를 볼 수 있는데 이게 바로 우리가 `GET`로 전송한 데이터.
  - `POST`는 이와 다르게 전송되는 데이터가 패킷에 숨겨져서 보내진다.  따라서 보안적인 측면에서는 `GET`보다는 훨씬 낫다. 하지만 요즘에는 이 방법도 완벽한 보안이 안돼서 `SSL` 방식도 사용함.

#### URI(Uniform Resource Identifier)

- URI는 주소창에 있는 문자열 전체를 의미한다. URL과 다르다!

- ***실제 의미는 인터넷 상에서 특정한 자원을 나타내는 유일한 주소다.***

- 우리가 받고 싶어하는 HTML, 이미지, 영상등은 서버에 저장이 되어있다. 그걸 나타내는 주소라고 생각하면 된다. 굉장히 복잡한 주소로 이루어짐.

- 구조
  - `scheme ://host[:port][/path][?query]`

    - `ftp ://IP주소 :포트 /파일이름`
    - `http ://IP주소 :포트 /폴더이름/파일이름`
    - `scheme`: 내가 요청하는 요청 형식. 보통 7계층 프로토톨
    - `IP주소, 포트번호` : 보통 여기에 도메인 주소를 씀. 하지만 내부적으로는 도메인주소를 IP주소로 바꿔준다. 포트번호는 지정하지 않으면 자동으로 `80` 또는 `443`을 웹브라우저가 자동으로 사용함.
    - `/파일이름, /폴더이름/파일이름`: 내가 원하는 특정 파일이 서버에 위치한 곳.

  - `https://comic.naver.com/webtoon/detail.nhn` 이라는 주소가 있으면 

    - `https: scheme`
    - `comic.naver.com` -> 도메인주소 = IP주소
    - `포트번호`는 생략
    - `webtoon` 폴더이름
    - `detail.nhn` 파일이름

    

## HTTP응답 프로토콜

#### HTTP 응답 프로토콜의 구조

| http 응답 프로토콜 계층구도 |                                                   |
| --------------------------- | ------------------------------------------------- |
| Status Line                 | `HTTP 버전 | 공백 | 상태 코드 | 공백 | 상태 문구` |
| Headers                     | 헤더는 아래에서                                   |
| 공백                        | 말 그대로 그냥 공백. 구분자의 역할을 한다.        |
| Body                        | 클라이언트가 요청한 데이터가 담김                 |

#### 상태코드

> 서버가 알려주는 여러가지 정보

| 상태 코드 종류                | 설명                                               |
| ----------------------------- | -------------------------------------------------- |
| 100 ~ 199                     | 단순한 정보                                        |
| 200 ~ 299(정상)               | Client의 요청이 성공                               |
| 300 ~ 399                     | Client의 요청이 수행되지 않다 다른 URL로 재지정    |
| 400 ~ 499 (클라이언트의 문제) | Client의 요청이 불완전하여 다른 정보가 필요        |
| 500 ~ 599 (서버의 문제)       | Server의 오류를 만나거나 Client의 요청 수행이 불가 |

| 상태 코드 상세 | 상태 문구             | 설명                                      |
| -------------- | --------------------- | ----------------------------------------- |
| 200            | OK                    | Client의 요청이  성공했다는 것을 나타냄   |
| 403            | Forbidden             | Client가 권한이 없는 페이지를 요청했을 때 |
| 404            | Not Found             | Client가 서버에 없는 페이지를 요청했을 때 |
| 500            | Internal Server Error | Server의 일부가 멈췄가나 설정 오류가 발생 |
| 503            | Service Unavailable   | 최대 Session 수를 초과했을 때             |



## HTTP 헤더 포맷

#### HTTP 헤더 구조

#### 일반 헤더

> 요청, 응답 모두가 사용 가능한 헤더
>
> 일반적인 정보를 담고 있다.

| 헤더 종류      | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| Content-Length | 메시지 바디 길이를 나타탤 때 쓰인다.                         |
| Content-Type   | 메시지 바디에 들어있는 컨텐츠 종류<br />(Ex: HTML 문서는text/html) |

#### 요청 헤더

> 클라이언트 정보를 담고 있는 헤더

| 헤더 종류  | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| Cookie     | 서버로 부터 받은 쿠키를 다시 서버에게 보내주는 역할을 한다.  |
| Host(필수) | 요청된 URL에 나타난 호스트명을 상세하게 표시(HTTP/1.1 은 필수) |
| User-Agent | Client Program에 대한 식별 가능 정보를 제공<br />(이 정보를 이용하면 어떤 기기(모바일, 컴퓨터..)로 접속했는지 알 수 있음) |

#### 응답 헤더

> 서버의 정보를 담고 있다.

| 헤더 종류  | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| Server     | 사용하고 있는 웹서버의 소프트웨어에 대한 정보를 포함 (보안상의 이유로 주로 닫아 놓는다.) |
| Set-Cookie | 쿠키를 생성하고 브라우저에 보낼 때 사용.<br />해당 쿠키 값을 브라우저가 서버에게 다시 보낼 때 사용한다. |



## 실습